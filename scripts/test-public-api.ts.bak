/**
 * Test script for Public Artists API
 *
 * Run with: npx ts-node scripts/test-public-api.ts
 *
 * Tests all query parameter combinations and validates response format
 */

const BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000'

interface TestResult {
  name: string
  passed: boolean
  error?: string
  duration?: number
  responseData?: any
}

const results: TestResult[] = []

async function runTest(
  name: string,
  endpoint: string,
  expectedStatus: number = 200,
  validator?: (data: any) => void
) {
  const startTime = Date.now()

  try {
    console.log(`\nðŸ§ª Running: ${name}`)
    console.log(`   URL: ${BASE_URL}${endpoint}`)

    const response = await fetch(`${BASE_URL}${endpoint}`)
    const duration = Date.now() - startTime

    console.log(`   Status: ${response.status} (expected ${expectedStatus})`)
    console.log(`   Duration: ${duration}ms`)

    if (response.status !== expectedStatus) {
      throw new Error(`Expected status ${expectedStatus}, got ${response.status}`)
    }

    const data = await response.json()

    // Log cache headers
    const cacheStatus = response.headers.get('X-Cache')
    const cacheAge = response.headers.get('X-Cache-Age')
    if (cacheStatus) {
      console.log(`   Cache: ${cacheStatus}${cacheAge ? ` (${cacheAge}s old)` : ''}`)
    }

    // Log rate limit headers
    const rateLimit = response.headers.get('X-RateLimit-Limit')
    if (rateLimit) {
      console.log(`   Rate Limit: ${rateLimit}/hour`)
    }

    // Validate response structure
    if (expectedStatus === 200) {
      // Check required top-level fields
      if (!data.platform || data.platform !== 'Bright Ears') {
        throw new Error('Missing or invalid platform field')
      }
      if (!data.description) {
        throw new Error('Missing description field')
      }
      if (!data.apiVersion) {
        throw new Error('Missing apiVersion field')
      }
      if (typeof data.totalArtists !== 'number') {
        throw new Error('Missing or invalid totalArtists field')
      }
      if (typeof data.resultCount !== 'number') {
        throw new Error('Missing or invalid resultCount field')
      }
      if (!Array.isArray(data.artists)) {
        throw new Error('artists must be an array')
      }

      console.log(`   Total Artists: ${data.totalArtists}`)
      console.log(`   Results: ${data.resultCount} artists`)

      // Validate first artist structure (if any)
      if (data.artists.length > 0) {
        const artist = data.artists[0]
        console.log(`   Sample: ${artist.stageName} - ${artist.categories[0]}`)

        const requiredFields = [
          'id', 'stageName', 'categories', 'bio', 'pricing',
          'location', 'verified', 'profileUrl', 'contactMethods'
        ]

        for (const field of requiredFields) {
          if (!(field in artist)) {
            throw new Error(`Missing required field in artist: ${field}`)
          }
        }

        // Validate pricing structure
        if (!artist.pricing.currency || artist.pricing.currency !== 'THB') {
          throw new Error('Invalid pricing.currency')
        }
        if (typeof artist.pricing.minimumHours !== 'number') {
          throw new Error('Invalid pricing.minimumHours')
        }

        // Validate location structure
        if (!Array.isArray(artist.location.serviceAreas)) {
          throw new Error('location.serviceAreas must be an array')
        }
        if (typeof artist.location.basedIn !== 'string') {
          throw new Error('Invalid location.basedIn')
        }

        // Validate arrays
        if (!Array.isArray(artist.categories)) {
          throw new Error('categories must be an array')
        }
        if (!Array.isArray(artist.contactMethods)) {
          throw new Error('contactMethods must be an array')
        }

        // Validate URL format
        if (!artist.profileUrl.startsWith('https://')) {
          throw new Error('profileUrl must be HTTPS')
        }
      }

      // Run custom validator if provided
      if (validator) {
        validator(data)
      }
    }

    results.push({
      name,
      passed: true,
      duration,
      responseData: expectedStatus === 200 ? data : undefined
    })

    console.log(`   âœ… PASSED`)

  } catch (error) {
    const duration = Date.now() - startTime
    const errorMessage = error instanceof Error ? error.message : String(error)

    results.push({
      name,
      passed: false,
      error: errorMessage,
      duration
    })

    console.log(`   âŒ FAILED: ${errorMessage}`)
  }
}

async function runAllTests() {
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
  console.log('   PUBLIC ARTISTS API TEST SUITE')
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')

  // Test 1: Basic endpoint (no filters)
  await runTest(
    'Basic query - No filters',
    '/api/public/artists',
    200,
    (data) => {
      if (data.filters.category !== null) {
        throw new Error('Expected null category filter')
      }
      if (data.filters.city !== null) {
        throw new Error('Expected null city filter')
      }
      if (data.filters.limit !== 20) {
        throw new Error('Expected default limit of 20')
      }
    }
  )

  // Test 2: Category filter - DJ
  await runTest(
    'Category filter - DJ',
    '/api/public/artists?category=DJ',
    200,
    (data) => {
      if (data.filters.category !== 'DJ') {
        throw new Error('Expected DJ category in filters')
      }
      // Verify all artists are DJs
      data.artists.forEach((artist: any, idx: number) => {
        if (!artist.categories.includes('DJ')) {
          throw new Error(`Artist ${idx} is not a DJ: ${artist.categories}`)
        }
      })
    }
  )

  // Test 3: Category filter - BAND
  await runTest(
    'Category filter - BAND',
    '/api/public/artists?category=BAND',
    200
  )

  // Test 4: City filter - Bangkok
  await runTest(
    'City filter - Bangkok',
    '/api/public/artists?city=Bangkok',
    200,
    (data) => {
      if (data.filters.city !== 'Bangkok') {
        throw new Error('Expected Bangkok city in filters')
      }
      // Verify all artists serve Bangkok
      data.artists.forEach((artist: any, idx: number) => {
        const servesCity = artist.location.basedIn.toLowerCase().includes('bangkok') ||
                          artist.location.serviceAreas.some((area: string) =>
                            area.toLowerCase().includes('bangkok')
                          )
        if (!servesCity) {
          throw new Error(`Artist ${idx} doesn't serve Bangkok`)
        }
      })
    }
  )

  // Test 5: Combined filters - DJ in Bangkok
  await runTest(
    'Combined filters - DJ in Bangkok',
    '/api/public/artists?category=DJ&city=Bangkok',
    200,
    (data) => {
      if (data.filters.category !== 'DJ' || data.filters.city !== 'Bangkok') {
        throw new Error('Expected DJ and Bangkok filters')
      }
    }
  )

  // Test 6: Limit parameter - 10 results
  await runTest(
    'Limit parameter - 10 results',
    '/api/public/artists?limit=10',
    200,
    (data) => {
      if (data.filters.limit !== 10) {
        throw new Error('Expected limit of 10')
      }
      if (data.artists.length > 10) {
        throw new Error(`Expected max 10 artists, got ${data.artists.length}`)
      }
    }
  )

  // Test 7: Limit parameter - 50 results (max)
  await runTest(
    'Limit parameter - 50 results (max)',
    '/api/public/artists?limit=50',
    200,
    (data) => {
      if (data.filters.limit !== 50) {
        throw new Error('Expected limit of 50')
      }
      if (data.artists.length > 50) {
        throw new Error(`Expected max 50 artists, got ${data.artists.length}`)
      }
    }
  )

  // Test 8: Verified filter
  await runTest(
    'Verified filter - true',
    '/api/public/artists?verified=true',
    200,
    (data) => {
      // In agency model, all artists should be verified
      data.artists.forEach((artist: any, idx: number) => {
        if (!artist.verified) {
          throw new Error(`Artist ${idx} is not verified`)
        }
      })
    }
  )

  // Test 9: Case insensitive category
  await runTest(
    'Case insensitive category - lowercase dj',
    '/api/public/artists?category=dj',
    200,
    (data) => {
      if (data.filters.category !== 'DJ') {
        throw new Error('Expected uppercase DJ in filters')
      }
    }
  )

  // Test 10: Invalid category (should return 400)
  await runTest(
    'Invalid category - INVALID',
    '/api/public/artists?category=INVALID',
    400
  )

  // Test 11: Limit too high (should clamp to 50)
  await runTest(
    'Limit too high - 100 (should clamp to 50)',
    '/api/public/artists?limit=100',
    400 // Zod validation should reject this
  )

  // Test 12: Limit too low (should reject)
  await runTest(
    'Limit too low - 0',
    '/api/public/artists?limit=0',
    400 // Zod validation should reject this
  )

  // Test 13: Cache test - run same query twice
  console.log('\nðŸ”„ Testing cache behavior...')
  await runTest(
    'Cache test - First request (MISS)',
    '/api/public/artists?category=DJ&limit=5',
    200
  )

  // Wait 1 second and run same query again
  await new Promise(resolve => setTimeout(resolve, 1000))

  await runTest(
    'Cache test - Second request (HIT)',
    '/api/public/artists?category=DJ&limit=5',
    200,
    (data) => {
      // Second request should return same data
    }
  )

  // Test 14: CORS headers
  console.log('\nðŸŒ Testing CORS headers...')
  const corsResponse = await fetch(`${BASE_URL}/api/public/artists`)
  const corsHeader = corsResponse.headers.get('Access-Control-Allow-Origin')
  console.log(`   CORS: ${corsHeader}`)
  if (corsHeader !== '*') {
    results.push({
      name: 'CORS headers',
      passed: false,
      error: 'Expected Access-Control-Allow-Origin: *'
    })
    console.log('   âŒ FAILED: CORS not enabled')
  } else {
    results.push({ name: 'CORS headers', passed: true })
    console.log('   âœ… PASSED')
  }

  // Print summary
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
  console.log('   TEST SUMMARY')
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')

  const passed = results.filter(r => r.passed).length
  const failed = results.filter(r => !r.passed).length
  const total = results.length

  console.log(`\nTotal Tests: ${total}`)
  console.log(`âœ… Passed: ${passed}`)
  console.log(`âŒ Failed: ${failed}`)

  if (failed > 0) {
    console.log('\nâŒ FAILED TESTS:')
    results
      .filter(r => !r.passed)
      .forEach(r => {
        console.log(`   - ${r.name}`)
        console.log(`     Error: ${r.error}`)
      })
  }

  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n')

  // Exit with error code if any tests failed
  process.exit(failed > 0 ? 1 : 0)
}

// Run tests
runAllTests().catch(error => {
  console.error('Fatal error running tests:', error)
  process.exit(1)
})
